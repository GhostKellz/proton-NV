From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Proton-NV <proton-nv@nvidia-linux>
Date: Sat, 29 Nov 2025 00:00:00 +0000
Subject: [PATCH] proton: BORE + EEVDF scheduler gaming optimizations

Optimizations for BORE (Burst-Oriented Response Enhancer) running on top
of EEVDF (Earliest Eligible Virtual Deadline First) scheduler.

This is the default scheduler stack in:
- CachyOS kernel 6.6+
- Linux-tkg with BORE 6.8+
- Mainline with BORE patches 6.17/6.18+

BORE + EEVDF benefits for gaming:
- EEVDF provides fair scheduling with virtual deadlines
- BORE adds burst tolerance for game frame rendering
- Combined: consistent frame times with good responsiveness
- Better than CFS for interactive/gaming workloads
---
diff --git a/proton-nv-bore-eevdf.sh b/proton-nv-bore-eevdf.sh
new file mode 100755
index 0000000..1111111
--- /dev/null
+++ b/proton-nv-bore-eevdf.sh
@@ -0,0 +1,198 @@
+#!/bin/bash
+#
+# Proton-NV BORE + EEVDF Scheduler Tuning
+#
+# Optimizations for gaming on:
+# - CachyOS kernel (6.6+)
+# - Linux-tkg with BORE (6.8+)
+# - Mainline with BORE patches (6.17/6.18+)
+#
+
+set -e
+
+PROTON_NV_VERSION="1.0"
+VERBOSE="${PROTON_NV_VERBOSE:-0}"
+
+log() {
+    if [ "$VERBOSE" = "1" ]; then
+        echo "[Proton-NV] $*" >&2
+    fi
+}
+
+warn() {
+    echo "[Proton-NV WARNING] $*" >&2
+}
+
+###############################################################################
+# Kernel and Scheduler Detection
+###############################################################################
+
+get_kernel_version() {
+    uname -r
+}
+
+get_kernel_major() {
+    uname -r | cut -d. -f1
+}
+
+get_kernel_minor() {
+    uname -r | cut -d. -f2
+}
+
+# Detect scheduler type
+detect_scheduler() {
+    local sched=""
+
+    # Check for BORE+EEVDF (most performant for gaming)
+    if [ -f /sys/kernel/debug/sched/features ]; then
+        local features=$(cat /sys/kernel/debug/sched/features 2>/dev/null || echo "")
+        if echo "$features" | grep -q "BORE"; then
+            sched="bore"
+            if echo "$features" | grep -q "EEVDF"; then
+                sched="bore-eevdf"
+            fi
+        elif echo "$features" | grep -q "EEVDF"; then
+            sched="eevdf"
+        fi
+    fi
+
+    # Check kernel name for CachyOS/tkg hints
+    local kver=$(uname -r)
+    if echo "$kver" | grep -qi "cachyos"; then
+        if [ -z "$sched" ]; then
+            sched="bore-eevdf"  # CachyOS default
+        fi
+    elif echo "$kver" | grep -qi "tkg"; then
+        if [ -z "$sched" ]; then
+            sched="bore"  # TKG with BORE
+        fi
+    fi
+
+    # Fallback: check kernel version for EEVDF (mainline 6.6+)
+    if [ -z "$sched" ]; then
+        local major=$(get_kernel_major)
+        local minor=$(get_kernel_minor)
+        if [ "$major" -gt 6 ] || ([ "$major" -eq 6 ] && [ "$minor" -ge 6 ]); then
+            sched="eevdf"
+        else
+            sched="cfs"
+        fi
+    fi
+
+    echo "$sched"
+}
+
+###############################################################################
+# BORE + EEVDF Tuning Parameters
+###############################################################################
+
+# Gaming-optimized scheduler parameters
+# These prioritize latency and frame time consistency
+
+apply_bore_eevdf_tuning() {
+    local game_pid="$1"
+
+    log "Applying BORE+EEVDF gaming tuning..."
+
+    # System-wide scheduler tuning (requires privileges)
+    if [ -w /proc/sys/kernel ]; then
+
+        # Scheduler latency (nanoseconds)
+        # Default: 6ms, Gaming: 3-4ms
+        # Lower = more responsive, but more context switches
+        if [ -f /proc/sys/kernel/sched_latency_ns ]; then
+            echo 3000000 > /proc/sys/kernel/sched_latency_ns 2>/dev/null && \
+                log "  sched_latency_ns: 3ms (gaming)"
+        fi
+
+        # Minimum granularity for preemption
+        # Default: 0.75ms, Gaming: 0.4ms
+        if [ -f /proc/sys/kernel/sched_min_granularity_ns ]; then
+            echo 400000 > /proc/sys/kernel/sched_min_granularity_ns 2>/dev/null && \
+                log "  sched_min_granularity_ns: 0.4ms (gaming)"
+        fi
+
+        # Wakeup granularity
+        # Default: 1ms, Gaming: 0.5ms
+        if [ -f /proc/sys/kernel/sched_wakeup_granularity_ns ]; then
+            echo 500000 > /proc/sys/kernel/sched_wakeup_granularity_ns 2>/dev/null && \
+                log "  sched_wakeup_granularity_ns: 0.5ms (gaming)"
+        fi
+
+        # BORE-specific: Burst scoring parameters
+        # Higher burst tolerance = better for game frame rendering
+        if [ -f /proc/sys/kernel/sched_burst_cache_lifetime ]; then
+            echo 60000000 > /proc/sys/kernel/sched_burst_cache_lifetime 2>/dev/null && \
+                log "  sched_burst_cache_lifetime: 60ms (gaming)"
+        fi
+
+        if [ -f /proc/sys/kernel/sched_burst_fork_atavistic ]; then
+            echo 1 > /proc/sys/kernel/sched_burst_fork_atavistic 2>/dev/null && \
+                log "  sched_burst_fork_atavistic: enabled"
+        fi
+
+        if [ -f /proc/sys/kernel/sched_burst_penalty_offset ]; then
+            echo 22 > /proc/sys/kernel/sched_burst_penalty_offset 2>/dev/null && \
+                log "  sched_burst_penalty_offset: 22 (gaming)"
+        fi
+
+        if [ -f /proc/sys/kernel/sched_burst_smoothness_long ]; then
+            echo 1 > /proc/sys/kernel/sched_burst_smoothness_long 2>/dev/null && \
+                log "  sched_burst_smoothness_long: 1 (gaming)"
+        fi
+
+        if [ -f /proc/sys/kernel/sched_burst_smoothness_short ]; then
+            echo 0 > /proc/sys/kernel/sched_burst_smoothness_short 2>/dev/null && \
+                log "  sched_burst_smoothness_short: 0 (gaming)"
+        fi
+
+    else
+        log "  (no write access to /proc/sys/kernel - use gamemode or run as root)"
+    fi
+
+    # Per-process tuning (if PID provided)
+    if [ -n "$game_pid" ] && [ -d "/proc/$game_pid" ]; then
+        # Set SCHED_BATCH for better throughput on game process
+        # (though BORE makes this less critical)
+        # chrt -b -p 0 "$game_pid" 2>/dev/null && log "  Set SCHED_BATCH for PID $game_pid"
+
+        # Set nice value
+        renice -n -5 -p "$game_pid" 2>/dev/null && \
+            log "  Set nice -5 for PID $game_pid"
+
+        # IO scheduling
+        ionice -c 2 -n 0 -p "$game_pid" 2>/dev/null && \
+            log "  Set ionice best-effort:0 for PID $game_pid"
+    fi
+}
+
+###############################################################################
+# EEVDF-only Tuning (fallback for mainline without BORE)
+###############################################################################
+
+apply_eevdf_tuning() {
+    log "Applying EEVDF gaming tuning (no BORE)..."
+
+    # EEVDF-specific parameters
+    if [ -w /proc/sys/kernel ]; then
+        # Similar latency tuning, but without BORE burst parameters
+        if [ -f /proc/sys/kernel/sched_latency_ns ]; then
+            echo 4000000 > /proc/sys/kernel/sched_latency_ns 2>/dev/null
+        fi
+        if [ -f /proc/sys/kernel/sched_min_granularity_ns ]; then
+            echo 500000 > /proc/sys/kernel/sched_min_granularity_ns 2>/dev/null
+        fi
+    fi
+}
+
+###############################################################################
+# Main Entry Point
+###############################################################################
+
+apply_gaming_tuning() {
+    local scheduler=$(detect_scheduler)
+    log "Detected scheduler: $scheduler"
+
+    case "$scheduler" in
+        bore-eevdf|bore) apply_bore_eevdf_tuning "$1" ;;
+        eevdf) apply_eevdf_tuning "$1" ;;
+        *) log "Unknown scheduler, no tuning applied" ;;
+    esac
+}
+
+# Export for use by proton script
+export -f apply_gaming_tuning detect_scheduler
